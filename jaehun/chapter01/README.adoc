= 01. Static Checking

== Hailstone Sequence

* 우박 수열
* n이라는 숫자로 시작할 경우
** 짝수 -> n / 2
** 홀수 -> 3 * n + 1
** 1이 될때까지 반복한다.

[source, console]
----
2, 1
3, 10, 5, 16, 8, 4, 2, 1
4, 2, 1
2n, 2n-1, ... , 4, 2, 1
...
----

== Computing Hailstones

[source, java]
----
public class Hailstone {
    public static void main(String[] args) {
        int n  = 3;
        while (n != 1) {
            System.out.println(n);

            if (n % 2 == 0)
                n = n / 2;
            else
                n = 3 * n + 1;
        }

        System.out.println(n);

    }
}
----

* Java의 expression과 statement에 대한 기본 의미는 파이썬과 유사하다.
* Java는 한 statement가 끝날 때 `세미콜론(;)` 을 작성해야하는데 코드를 작성하는데 더 많은 자유를 얻을 수 있다.
* 파이썬과 다르게 if 문이나 while 문에 대해서 추가적인 `indentation(들여쓰기)` 을 요구하지 않는다. 그저 중괄호로 구분해주면 된다.
* 프로그래밍은 의사소통의 한 형태이다. 그래서 컴파일러 뿐 아니라 다른 사람들과도 의사소통을 해야하기 때문에 들여쓰기를 해주는것이 좋다.

== Types
* 파이썬과 자바의 코드중 가장 중요한 의미적인 차이는 변수 n을 정의하는 것.
* 파이썬은 특별한 타입 지정자를 필요로 하지 않지만 자바는 int, double 과 같은 type을 지정해 주어야 한다.

* Java convention에서 Primitive type은 소문자로 Object type은 대문자로 시작한다.

== Static Typing
* 자바는 정적 타입의 언어이다. (statically typed language)
* 모든 변수들의 타입이 컴파일 타임에 결정되어야 하고, 컴파일러는 모든 표현식에 대한 타입을 추론할 수 있어야 한다.
* static typing이란 static checking의 일부이기 때문에 컴파일 시간에 버그들을 체크할 수 있다는 것을 의미한다.

== Static Checking, Dynamic Checking, No Checking

Static checking::
버그를 프로그램이 실행되기 전에 찾을 수 있다.
* syntax 에러를 발견할 수 있다.
* 메서드의 이름을 잘못 작성하거나 메서드에 대한 시그니처를 잘못 작성하였을 경우.

Dynamic checking::
버그를 프로그램이 실행될 때 찾을 수 있다.
* `x/y` 의 경우 y의 값이 0인 경우.
* 표현할 수 없는 return value인 경우.
* index의 범위를 벗어난 경우
* object에 대한 references가 null인 경우

No checking::
에러를 찾는 것을 돕지 않는다. 작성자 스스로 발견해야 한다.


== Arrays and Collections
sequence를 데이터 구조에 저장하는 방법

=== Array
* 고정된 크기의 특정 타입 T의 시퀀스.
* `int[]` 는 정수들의 배열.

[source]
----
int[] a = new int[100];
int i = 0;
int n = 3;
while (n != 1) {
    a[i] = n;
    i++;
    if (n % 2 == 0)
        n = n / 2;
    else
        n = 3 * n + 1;
)
a[i] = n;
i++;
----

* a 배열의 크기가 고정적이므로 index의 범위를 벗어나는 경우가 발생한다면? +
에러가 발생한다.

{empty}

=== List
* 가변 길이의 T의 시퀀스.
[source]
----
List<Integer> list = new ArrayList<>();
----

* List는 new로 생성이 불가능하지만 list가 해야 할 작업을 지정할 수 있는 인터페이스.
* Array List는 이런 작업을 구현하는 구체적인 타입이다. (concrete type)
* List는 primitive 타입을 가질 수 없다. object type을 가져야 한다.
* 각각의 primitive 타입은 동등한 object type이 존재한다.

[source]
----
List<Integer> list = new ArrayList<>();
int n = 3;
while (n != 1) {
    list.add(n);

    if (n % 2 == 0)
        n = n / 2;
    else
        n = 3 * n + 1;
}
list.add(n);
----

== Iterating
[source]
----
int max = 0;
for (int x : list) {
    max = Math.max(x, max);
}
----

== Method
* Java의 statement는 일반적으로 메소드 안에 존재해야 한다.
* 모든 메소드들은 클래스 안에 존재해야 한다.

[source, java]
----
import java.util.ArrayList;

public class Hailstone {
    /**
       * Compute a hailstone sequence.
       * @param n  Starting number for sequence.  Assumes n > 0.
       * @return hailstone sequence starting with n and ending with 1.
         */
    public static List<Integer> hailstoneSequence (int n) {
        List<Integer> list = new ArrayList<>();

        while (n != 1) {
            list.add(n);

            if (n % 2 == 0)
                n = n / 2;
            else
                n = 3 * n + 1;
        }

        list.add(n);

        return list;
    }
}
----

* JavaDoc : 해당 메소드의 입력과 출력에 대한 설명이 있다.
** 매개변수인 n에 대해서 int n 으로 선언되어 있기 때문에 n이 정수라는 설명은 필요없지만
사용자는 n이 양수여야 한다는 것을 알아야 하기 때문에 JavaDoc을 통해 설명한다.

== Mutating Values VS. Reassigning Variables
변수에 값을 할당하면 변수가 가르키는 위치가 변경된다. +
array나 list같은 변경 가능한 값의 내용에 할당하면 해당 값 내부의 참조가 변경된다.

* 변화는 예측할 수 없기 때문에 좋은 프로그래머는 변경하는것을 피한다.
* 불변성(Immutability)는 이런 과정에서 좋은 설계 원칙이다.
* 불변 타입은 생성한 이후 절대 변경할 수 없는 타입이다.
* `final` 키워드를 통해서 불변 타입을 만들수 있다.

* 메소드의 매개변수와 많은 지역변수를 final로 선언하는 것은 좋은 방법이다.

link:Quiz.adoc[QUIZ]